<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>app/server/packages/Package.js - OpenVeo Publish server</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo Publish server</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 11.1.1
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ConfigurationController.html">ConfigurationController</a></li>
                                <li><a href="../classes/DirectoryFsWatcher.html">DirectoryFsWatcher</a></li>
                                <li><a href="../classes/DirectoryWatcher.html">DirectoryWatcher</a></li>
                                <li><a href="../classes/ERRORS.html">ERRORS</a></li>
                                <li><a href="../classes/factory.html">factory</a></li>
                                <li><a href="../classes/GoogleOAuthHelper.html">GoogleOAuthHelper</a></li>
                                <li><a href="../classes/HTTP_ERRORS.html">HTTP_ERRORS</a></li>
                                <li><a href="../classes/listener.html">listener</a></li>
                                <li><a href="../classes/LocalProvider.html">LocalProvider</a></li>
                                <li><a href="../classes/mediaPlatformFactory.html">mediaPlatformFactory</a></li>
                                <li><a href="../classes/MediaPlatformProvider.html">MediaPlatformProvider</a></li>
                                <li><a href="../classes/Package.html">Package</a></li>
                                <li><a href="../classes/PackageError.html">PackageError</a></li>
                                <li><a href="../classes/PoiProvider.html">PoiProvider</a></li>
                                <li><a href="../classes/PropertyController.html">PropertyController</a></li>
                                <li><a href="../classes/PropertyProvider.html">PropertyProvider</a></li>
                                <li><a href="../classes/PUBLISH_HOOKS.html">PUBLISH_HOOKS</a></li>
                                <li><a href="../classes/PublishError.html">PublishError</a></li>
                                <li><a href="../classes/PublishManager.html">PublishManager</a></li>
                                <li><a href="../classes/PublishPlugin.html">PublishPlugin</a></li>
                                <li><a href="../classes/PublishPluginApi.html">PublishPluginApi</a></li>
                                <li><a href="../classes/ResumableUpload.html">ResumableUpload</a></li>
                                <li><a href="../classes/STATES.html">STATES</a></li>
                                <li><a href="../classes/StatisticsController.html">StatisticsController</a></li>
                                <li><a href="../classes/TarPackage.html">TarPackage</a></li>
                                <li><a href="../classes/TarPackageError.html">TarPackageError</a></li>
                                <li><a href="../classes/TlsClient.html">TlsClient</a></li>
                                <li><a href="../classes/TlsProvider.html">TlsProvider</a></li>
                                <li><a href="../classes/TYPES.html">TYPES</a></li>
                                <li><a href="../classes/VideoController.html">VideoController</a></li>
                                <li><a href="../classes/VideoPackage.html">VideoPackage</a></li>
                                <li><a href="../classes/VideoPackageError.html">VideoPackageError</a></li>
                                <li><a href="../classes/VideoProvider.html">VideoProvider</a></li>
                                <li><a href="../classes/VimeoProvider.html">VimeoProvider</a></li>
                                <li><a href="../classes/Watcher.html">Watcher</a></li>
                                <li><a href="../classes/WatcherError.html">WatcherError</a></li>
                                <li><a href="../classes/WowzaProvider.html">WowzaProvider</a></li>
                                <li><a href="../classes/YoutubeProvider.html">YoutubeProvider</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/controllers.html">controllers</a></li>
                                <li><a href="../modules/packages.html">packages</a></li>
                                <li><a href="../modules/providers.html">providers</a></li>
                                <li><a href="../modules/publish.html">publish</a></li>
                                <li><a href="../modules/watcher.html">watcher</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/server/packages/Package.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
 * @module packages
 */

var util = require(&#x27;util&#x27;);
var fs = require(&#x27;fs&#x27;);
var events = require(&#x27;events&#x27;);
var path = require(&#x27;path&#x27;);
var async = require(&#x27;async&#x27;);
var StateMachine = require(&#x27;javascript-state-machine&#x27;);
var openVeoApi = require(&#x27;@openveo/api&#x27;);
var configDir = openVeoApi.fileSystem.getConfDir();
var mediaPlatformFactory = process.requirePublish(&#x27;app/server/providers/mediaPlatforms/factory.js&#x27;);
var publishConf = require(path.join(configDir, &#x27;publish/publishConf.json&#x27;));
var videoPlatformConf = require(path.join(configDir, &#x27;publish/videoPlatformConf.json&#x27;));
var ERRORS = process.requirePublish(&#x27;app/server/packages/errors.js&#x27;);
var STATES = process.requirePublish(&#x27;app/server/packages/states.js&#x27;);
var PackageError = process.requirePublish(&#x27;app/server/packages/PackageError.js&#x27;);
var ResourceFilter = openVeoApi.storages.ResourceFilter;

/**
 * Fired when an error occurred while processing the package.
 *
 * @event error
 * @param {Error} The error
 */

/**
 * Fired when package processing has succeed.
 *
 * @event complete
 * @param {Object} The processed package
 */

/**
 * Fired when package state has changed.
 *
 * @event stateChanged
 * @param {Object} The processed package
 */

/**
 * Defines a Package to manage publication of a media file.
 *
 * @class Package
 * @constructor
 * @param {Object} mediaPackage Information about the media
 * @param {VideoProvider} videoProvider Media provider
 * @param {PoiProvider} poiProvider Points of interest provider
 */
function Package(mediaPackage, videoProvider, poiProvider) {

  Object.defineProperties(this, {

    /**
     * Publish configuration.
     *
     * @property publishConf
     * @type Object
     * @final
     */
    publishConf: {value: publishConf},

    /**
     * Media provider.
     *
     * @property videoProvider
     * @type VideoProvider
     * @final
     */
    videoProvider: {value: videoProvider},

    /**
     * Points of interest provider.
     *
     * @property poiProvider
     * @type PoiProvider
     * @final
     */
    poiProvider: {value: poiProvider},

    /**
     * Media package description object.
     *
     * @property mediaPackage
     * @type Object
     */
    mediaPackage: {value: mediaPackage, writable: true},

    /**
     * Video platforms configuration object from videoPlatformConf.json file.
     *
     * @property videoPlatformConf
     * @type Object
     * @final
     */
    videoPlatformConf: {value: videoPlatformConf}

  });

  // Validate temporary directory
  if (!this.publishConf.videoTmpDir || (typeof this.publishConf.videoTmpDir !== &#x27;string&#x27;))
    this.emit(&#x27;error&#x27;, new PackageError(&#x27;videoTmpDir in publishConf.json must be a String&#x27;),
      ERRORS.INVALID_CONFIGURATION);
}

util.inherits(Package, events.EventEmitter);
module.exports = Package;

/**
 * Package states.
 *
 * @property STATES
 * @type Object
 * @static
 * @final
 */
Package.STATES = {
  PACKAGE_SUBMITTED: &#x27;packageSubmitted&#x27;,
  PACKAGE_INITIALIZED: &#x27;packageInitialized&#x27;,
  PACKAGE_COPIED: &#x27;packageCopied&#x27;,
  ORIGINAL_PACKAGE_REMOVED: &#x27;originalPackageRemoved&#x27;,
  MEDIA_UPLOADED: &#x27;mediaUploaded&#x27;,
  MEDIA_SYNCHRONIZED: &#x27;mediaSynchronized&#x27;,
  DIRECTORY_CLEANED: &#x27;directoryCleaned&#x27;
};
Object.freeze(Package.STATES);

/**
 * Package transitions (from one state to another).
 *
 * @property TRANSITIONS
 * @type Object
 * @static
 * @final
 */
Package.TRANSITIONS = {
  INIT: &#x27;initPackage&#x27;,
  COPY_PACKAGE: &#x27;copyPackage&#x27;,
  REMOVE_ORIGINAL_PACKAGE: &#x27;removeOriginalPackage&#x27;,
  UPLOAD_MEDIA: &#x27;uploadMedia&#x27;,
  SYNCHRONIZE_MEDIA: &#x27;synchronizeMedia&#x27;,
  CLEAN_DIRECTORY: &#x27;cleanDirectory&#x27;
};
Object.freeze(Package.TRANSITIONS);

/**
 * Define the order in which transitions will be executed for a Package.
 *
 * @property stateTransitions
 * @type Array
 * @static
 * @final
 */
Package.stateTransitions = [
  Package.TRANSITIONS.INIT,
  Package.TRANSITIONS.COPY_PACKAGE,
  Package.TRANSITIONS.REMOVE_ORIGINAL_PACKAGE,
  Package.TRANSITIONS.UPLOAD_MEDIA,
  Package.TRANSITIONS.SYNCHRONIZE_MEDIA,
  Package.TRANSITIONS.CLEAN_DIRECTORY
];
Object.freeze(Package.stateTransitions);

/**
 * Define machine state authorized transitions depending on previous and next states.
 *
 * @property stateMachine
 * @type Array
 * @static
 * @final
 */
Package.stateMachine = [
  {
    name: Package.TRANSITIONS.INIT,
    from: Package.STATES.PACKAGE_SUBMITTED,
    to: Package.STATES.PACKAGE_INITIALIZED
  },
  {
    name: Package.TRANSITIONS.COPY_PACKAGE,
    from: Package.STATES.PACKAGE_INITIALIZED,
    to: Package.STATES.PACKAGE_COPIED
  },
  {
    name: Package.TRANSITIONS.REMOVE_ORIGINAL_PACKAGE,
    from: Package.STATES.PACKAGE_COPIED,
    to: Package.STATES.ORIGINAL_PACKAGE_REMOVED
  },
  {
    name: Package.TRANSITIONS.UPLOAD_MEDIA,
    from: Package.STATES.ORIGINAL_PACKAGE_REMOVED,
    to: Package.STATES.MEDIA_UPLOADED
  },
  {
    name: Package.TRANSITIONS.SYNCHRONIZE_MEDIA,
    from: Package.STATES.MEDIA_UPLOADED,
    to: Package.STATES.MEDIA_SYNCHRONIZED
  },
  {
    name: Package.TRANSITIONS.CLEAN_DIRECTORY,
    from: Package.STATES.MEDIA_SYNCHRONIZED,
    to: Package.STATES.DIRECTORY_CLEANED
  }
];
Object.freeze(Package.stateMachine);

/**
 * Creates a state machine to publish the package.
 *
 * @method init
 * @param {String} initialState Initial machine state
 * @param {String} initialTransition Initial machine transition
 */
Package.prototype.init = function(initialState, initialTransition) {
  var self = this;

  // Get the list of package stack transitions
  var transitions = this.getTransitions(this);

  // Look for the initial transition in the stack of transitions
  var transitionIndex = transitions.indexOf(initialTransition);
  var transition = transitionIndex &gt;= 0 ? transitionIndex : 0;

  // Create a new final state machine
  this.fsm = new StateMachine({
    init: initialState,
    transitions: this.getStateMachine()
  });

  // Handle each enter state event to launch automatically the next
  // transition regarding the stack of transitions
  this.fsm.observe(&#x27;onEnterState&#x27;, function() {
    process.logger.verbose(&#x27;State = &#x27; + self.fsm.state, {id: self.mediaPackage.id});
    self.executeTransition((transitions[transition + 1]) ? transitions[++transition] : null);
  });

  // Handle each leave state event to execute the corresponding transition
  this.fsm.observe(&#x27;onLeaveState&#x27;, function(event) {
    process.logger.verbose(&#x27;Transition = &#x27; + event.transition, {id: self.mediaPackage.id});

    // Executes function corresponding to transition
    if (self[event.transition]) {
      return self[event.transition]().catch(function(error) {

        // TODO: see if it is possible to test current transition for setError second parameter
        self.setError(error, error.code === ERRORS.SAVE_PACKAGE_DATA);
        throw error;

      });
    } else {
      self.setError(new PackageError(&#x27;Transition &#x27; + event.transition + &#x27; does not exist&#x27;, ERRORS.TRANSITION), true);
      return false;
    }

  });
};

/**
 * Updates media state and sends an event to inform about state changed.
 *
 * @method updateState
 * @async
 * @param {Number} id The id of the media to update
 * @param {String} state The state of the media
 * @param {Function} callback The function to call when it&#x27;s done
 *   - **Error** The error if an error occurred, null otherwise
 *   - **Number** The number of updated items
 */
Package.prototype.updateState = function(id, state, callback) {
  var self = this;

  this.videoProvider.updateState(id, state, function(error, totalItems) {
    self.emit(&#x27;stateChanged&#x27;, self.mediaPackage);
    callback(error, totalItems);
  });
};

/**
 * Starts executing at the given transition.
 *
 * The rest of the transitions stack will be executed.
 *
 * @method executeTransition
 * @param {String} transition The transition to launch
 */
Package.prototype.executeTransition = function(transition) {
  var self = this;

  // Package is initialized
  // Memorize the last state and last transition of the package
  async.parallel([
    function(callback) {
      self.videoProvider.updateLastState(self.mediaPackage.id, self.fsm.state, callback);
    },
    function(callback) {
      self.videoProvider.updateLastTransition(self.mediaPackage.id, transition, callback);
    }
  ], function() {

    // If no more transition or upload transition reached without platform type
    // The publication is considered done
    if (!transition || (transition === Package.TRANSITIONS.UPLOAD_MEDIA &amp;&amp; !self.mediaPackage.type)) {

      // Package has not been uploaded yet and request a manual upload
      // Change package state
      if (transition === Package.TRANSITIONS.UPLOAD_MEDIA) {
        process.logger.debug(&#x27;Package &#x27; + self.mediaPackage.id + &#x27; is waiting for manual upload&#x27;);
        self.updateState(self.mediaPackage.id, STATES.WAITING_FOR_UPLOAD, function() {
          self.emit(&#x27;complete&#x27;, self.mediaPackage);
        });
      } else
        self.updateState(self.mediaPackage.id, STATES.READY, function() {
          self.emit(&#x27;complete&#x27;, self.mediaPackage);
        });
    } else {

      // Continue by executing the next transition in the stack
      self.fsm[transition]();

    }

  });

};

/**
 * Initializes and stores the package.
 *
 * This is a transition.
 *
 * @method initPackage
 * @return {Promise} Promise resolving when transition is done
 */
Package.prototype.initPackage = function() {
  process.logger.debug(&#x27;Init package &#x27; + this.mediaPackage.id);

  var self = this;

  return new Promise(function(resolve, reject) {
    var filter = new ResourceFilter().equal(&#x27;originalFileName&#x27;, self.mediaPackage.originalFileName);
    if (self.mediaPackage.type) filter.equal(&#x27;type&#x27;, self.mediaPackage.type);

    self.mediaPackage.state = STATES.PENDING;
    self.mediaPackage.link = null;
    self.mediaPackage.mediaId = null;
    self.mediaPackage.errorCode = ERRORS.NO_ERROR;
    self.mediaPackage.properties = self.mediaPackage.properties || {};
    self.mediaPackage.metadata = self.mediaPackage.metadata || {};
    self.mediaPackage.lastState = Package.STATES.PACKAGE_INITIALIZED;
    self.mediaPackage.lastTransition = Package.TRANSITIONS.COPY_PACKAGE;
    if (self.mediaPackage.date === undefined) self.mediaPackage.date = Date.now();
    self.videoProvider.add([self.mediaPackage], function(addError) {
      if (addError) return reject(new PackageError(addError.message, ERRORS.SAVE_PACKAGE_DATA));
      self.emit(&#x27;stateChanged&#x27;, self.mediaPackage);
      resolve();
    });
  });
};

/**
 * Copies package from its submitted directory to temporary directory.
 *
 * This is a transition.
 *
 * @method copyPackage
 * @return {Promise} Promise resolving when transition is done
 */
Package.prototype.copyPackage = function() {
  var self = this;

  return new Promise(function(resolve, reject) {

    // Destination of the copy
    var destinationFilePath = path.join(self.publishConf.videoTmpDir, String(self.mediaPackage.id),
      self.mediaPackage.id + &#x27;.&#x27; + self.mediaPackage.packageType);

    self.updateState(self.mediaPackage.id, STATES.COPYING, function() {

      // Copy package
      process.logger.debug(&#x27;Copy &#x27; + self.mediaPackage.originalPackagePath + &#x27; to &#x27; + destinationFilePath);
      openVeoApi.fileSystem.copy(self.mediaPackage.originalPackagePath, destinationFilePath, function(copyError) {
        if (copyError) reject(new PackageError(copyError.message, ERRORS.COPY));
        else resolve();
      });

    });
  });
};

/**
 * Removes original package.
 *
 * This is a transition.
 *
 * @method removeOriginalPackage
 * @return {Promise} Promise resolving when transition is done
 */
Package.prototype.removeOriginalPackage = function() {
  var self = this;

  return new Promise(function(resolve, reject) {
    async.parallel([

      function(callback) {

        // Try to remove the original package
        process.logger.debug(&#x27;Remove original package &#x27; + self.mediaPackage.originalPackagePath);
        fs.unlink(self.mediaPackage.originalPackagePath, function(error) {
          if (error) callback(new PackageError(error.message, ERRORS.UNLINK));
          else callback();
        });
      }

    ], function(error) {
      if (error) return reject(error);
      else resolve();
    });
  });
};

/**
 * Uploads the media to the video platform.
 *
 * This is a transition.
 *
 * @method uploadMedia
 * @return {Promise} Promise resolving when transition is done
 */
Package.prototype.uploadMedia = function() {
  var self = this;

  return new Promise(function(resolve, reject) {
    self.updateState(self.mediaPackage.id, STATES.UPLOADING, function() {

      // Get media plaform provider from package type
      var mediaPlatformProvider = mediaPlatformFactory.get(self.mediaPackage.type,
        self.videoPlatformConf[self.mediaPackage.type]);

      // Start uploading the media to the platform
      process.logger.debug(&#x27;Upload media &#x27; + self.mediaPackage.id);
      mediaPlatformProvider.upload(self.getMediaFilePath(), function(error, mediaId) {
        if (error) return reject(new PackageError(error.message, ERRORS.MEDIA_UPLOAD));

        async.series([

          function(callback) {
            self.mediaPackage.link = &#x27;/publish/video/&#x27; + self.mediaPackage.id;
            self.videoProvider.updateLink(self.mediaPackage.id, self.mediaPackage.link, callback);
          },

          function(callback) {
            self.mediaPackage.mediaId = [mediaId];
            self.videoProvider.updateMediaId(self.mediaPackage.id, self.mediaPackage.mediaId, callback);
          }

        ], function() {
          resolve();
        });

      });

    });
  });
};

/**
 * Synchronizes uploaded media information with the media platform.
 *
 * This is a transition.
 *
 * @method synchronizeMedia
 * @return {Promise} Promise resolving when transition is done
 */
Package.prototype.synchronizeMedia = function() {
  var self = this;

  return new Promise(function(resolve, reject) {
    process.logger.debug(&#x27;Synchronize media &#x27; + self.mediaPackage.id);

    self.updateState(self.mediaPackage.id, STATES.SYNCHRONIZING, function() {

      // Get media plaform provider from package type
      var mediaPlatformProvider = mediaPlatformFactory.get(self.mediaPackage.type,
        self.videoPlatformConf[self.mediaPackage.type]);

      // Synchronize media
      mediaPlatformProvider.update(self.mediaPackage, self.mediaPackage, true, function(error) {
        if (error) reject(new PackageError(error.message, ERRORS.MEDIA_SYNCHRONIZE));
        else resolve();
      });

    });
  });
};

/**
 * Removes extracted tar files from temporary directory.
 *
 * This is a transition.
 *
 * @method cleanDirectory
 * @return {Promise} Promise resolving when transition is done
 */
Package.prototype.cleanDirectory = function() {
  var self = this;

  return new Promise(function(resolve, reject) {
    var directoryToRemove = path.join(self.publishConf.videoTmpDir, String(self.mediaPackage.id));

    // Remove package temporary directory
    process.logger.debug(&#x27;Remove temporary directory &#x27; + directoryToRemove);
    openVeoApi.fileSystem.rmdir(directoryToRemove, function(error) {
      if (error) reject(new PackageError(error.message, ERRORS.CLEAN_DIRECTORY));
      else resolve();
    });
  });
};

/**
 * Gets the stack of transitions corresponding to the package.
 *
 * Each package has its own way to be published, thus transitions stack
 * is different by package.
 *
 * @method getTransitions
 * @return {Array} The stack of transitions
 */
Package.prototype.getTransitions = function() {
  return Package.stateTransitions;
};

/**
 * Gets the list of transitions states corresponding to the package.
 *
 * @method getStateMachine
 * @return {Array} The list of states/transitions
 */
Package.prototype.getStateMachine = function() {
  return Package.stateMachine;
};

/**
 * Gets the media file path of the package.
 *
 * @method getMediaFilePath
 * @return {String} System path of the media file
 */
Package.prototype.getMediaFilePath = function() {
  return path.join(this.publishConf.videoTmpDir,
    String(this.mediaPackage.id),
    this.mediaPackage.id + &#x27;.&#x27; + this.mediaPackage.packageType
  );
};

/**
 * Sets a package as in error.
 *
 * @method setError
 * @param {PublishError} error The package error
 * @param {boolean} doNotUpdateMedia true to simply emit the error without updating the media
 */
Package.prototype.setError = function(error, doNotUpdateMedia) {
  var self = this;

  // An error occurred
  if (error) {

    async.parallel([
      function(callback) {
        if (doNotUpdateMedia) return callback();
        self.updateState(self.mediaPackage.id, STATES.ERROR, callback);
      },
      function(callback) {
        if (doNotUpdateMedia) return callback();
        self.videoProvider.updateErrorCode(self.mediaPackage.id, error.code, callback);
      }
    ], function() {
      self.emit(&#x27;error&#x27;, error);
    });

  }
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
