<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>app/client/admin/js/ovPub/MediaController.js - OpenVeo Publish AngularJS back end</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo Publish AngularJS back end</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 11.1.0
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/millisecondsToTime.html">millisecondsToTime</a></li>
                                <li><a href="../classes/ovpTime.html">ovpTime</a></li>
                                <li><a href="../classes/publishService.html">publishService</a></li>
                                <li><a href="../classes/timeToMilliseconds.html">timeToMilliseconds</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ov.publish.html">ov.publish</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/client/admin/js/ovPub/MediaController.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

(function(app) {

  /**
   * Defines the media controller for the medias page.
   */
  function MediaController(
    $scope,
    $filter,
    $location,
    $window,
    $interval,
    $q,
    entityService,
    publishService,
    utilService,
    properties,
    platforms,
    groups,
    users,
    settings,
    tableReloadEventService,
    i18nService,
    publishName,
    OvUrlFactory
  ) {
    var entityType = &#x27;videos&#x27;;
    var isUserManager = $scope.hasPermission(&#x27;publish-manage-videos&#x27;);
    var addMediaPromise = null;
    var userFilterCanceller;
    var pollMediasPromise;

    $scope.properties = properties.data.entities;
    $scope.platforms = platforms.data.platforms;
    $scope.groups = groups.data.entities;
    $scope.users = users.data.entities;
    $scope.settings = settings.data.entity &amp;&amp; settings.data.entity.value;
    $scope.isCollapsed = true;
    $scope.fileToUpload = null;
    $scope.thumbToAdd = null;
    $scope.thumbToEdit = null;

    // Fetch permissions of the connected user for MediaController features
    $scope.rights = {};
    $scope.rights.add = $scope.checkAccess(&#x27;publish-add-&#x27; + entityType);
    $scope.rights.publish = $scope.checkAccess(&#x27;publish-publish-&#x27; + entityType);
    $scope.rights.editor = $scope.checkAccess(&#x27;publish-editor-&#x27; + entityType);
    $scope.rights.retry = $scope.checkAccess(&#x27;publish-retry-&#x27; + entityType);
    $scope.rights.upload = $scope.checkAccess(&#x27;publish-upload-&#x27; + entityType);
    $scope.rights.update = $scope.checkAccess(&#x27;publish-update-&#x27; + entityType);
    $scope.rights.remove = $scope.checkAccess(&#x27;publish-delete-&#x27; + entityType);

    // Define add form
    var scopeAddForm = $scope.addFormContainer = {};
    scopeAddForm.model = {
      date: new Date(),
      properties: {}
    };

    // Define edit form
    var scopeEditForm = $scope.editFormContainer = {};
    scopeEditForm.model = {};
    scopeEditForm.pendingEdition = false;
    scopeEditForm.pluginName = publishName;

    // Define datatable
    var scopeDataTable = $scope.tableContainer = {};
    scopeDataTable.pluginName = publishName;

    // TinyMCE options
    var tinyOptions = {
      plugins: &#x27;lists link autolink autoresize textpattern&#x27;,
      autoresize_bottom_margin: 20, // eslint-disable-line
      menubar: false,
      toolbar: &#x27;undo redo | styleselect removeformat | bold italic &#x27; +
      &#x27;| alignleft aligncenter alignright alignjustify | bullist numlist | link&#x27;,
      style_formats: [{ // eslint-disable-line
        title: &#x27;Headers&#x27;,
        items: [
          {title: &#x27;Header 1&#x27;, format: &#x27;h1&#x27;},
          {title: &#x27;Header 2&#x27;, format: &#x27;h2&#x27;},
          {title: &#x27;Header 3&#x27;, format: &#x27;h3&#x27;},
          {title: &#x27;Header 4&#x27;, format: &#x27;h4&#x27;}
        ]
      }, {
        title: &#x27;Inline&#x27;, items: [
          {title: &#x27;Bold&#x27;, icon: &#x27;bold&#x27;, format: &#x27;bold&#x27;},
          {title: &#x27;Italic&#x27;, icon: &#x27;italic&#x27;, format: &#x27;italic&#x27;},
          {title: &#x27;Underline&#x27;, icon: &#x27;underline&#x27;, format: &#x27;underline&#x27;},
          {title: &#x27;Code&#x27;, icon: &#x27;code&#x27;, format: &#x27;code&#x27;}
        ]
      }, {
        title: &#x27;Blocks&#x27;,
        items: [
          {title: &#x27;Paragraph&#x27;, format: &#x27;p&#x27;},
          {title: &#x27;Blockquote&#x27;, format: &#x27;blockquote&#x27;}
        ]
      }],
      content_css: &#x27;/be/css/tinymce.css?&#x27; + new Date().getTime() // eslint-disable-line
    };

    /**
     * Gets all categories and add a value for &quot;none&quot;.
     *
     * @param {String} label The label for &quot;no categories&quot;
     * @return {Array} The list of categories
     */
    function getSelectableCategories(label) {
      return [{
        value: null,
        name: $filter(&#x27;translate&#x27;)(label)
      }].concat(publishService.getCategoriesOptions());
    }

    /**
     * Opens a link in a new tab.
     *
     * @param {String} link Destination url
     */
    function goToPath(link) {
      $window.open(link, &#x27;_blank&#x27;);
    }

    /**
     * Opens an alert to display HTML code to share the media.
     *
     * @param {Object} media The media to share
     */
    function shareCode(media) {
      $scope.$emit(&#x27;setAlert&#x27;, &#x27;info&#x27;, [
        $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.SHARECODE&#x27;),
        &#x27;&lt;br&gt;&lt;br&gt;&lt;div class=&quot;well well-sm&quot;&gt;&lt;code&gt;&#x27;,
        &#x27;&amp;lt;iframe width=&quot;768&quot; height=&quot;500&quot; &#x27;,
        &#x27;src=&quot;&#x27; + $location.protocol() + &#x27;://&#x27; + $location.host() + &#x27;:&#x27; + $location.port() + media.link,
        &#x27;?fullscreen&amp;lang=&#x27; + i18nService.getLanguage() + &#x27;&quot;&#x27;,
        &#x27; frameborder=&quot;0&quot; allowfullscreen webkitallowfullscreen mozallowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt;&#x27;,
        &#x27;&lt;/div&gt;&#x27;
      ].join(&#x27;&#x27;), 0);
    }

    // Automatically update the list of medias
    if ($scope.settings &amp;&amp; $scope.settings.refreshInterval) {
      pollMediasPromise = $interval(function() {
        if (!scopeEditForm.pendingEdition) {
          entityService.deleteCache(entityType, publishName);
          tableReloadEventService.broadcast(function() {
            $scope.$emit(&#x27;setAlert&#x27;, &#x27;info&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.RELOAD&#x27;, null, {
              interval: $scope.settings.refreshInterval
            }), 4000);
          });
        }
      }, $scope.settings.refreshInterval * 1000);
    }

    /**
     * Retries a media which is on error.
     *
     * @param {Array} medias The list of medias to work on
     * @param {Function} reload Function to reload the datatable
     */
    function retryMedia(medias, reload) {
      publishService.retryMedia(medias.join(&#x27;,&#x27;))
        .then(function() {
          $scope.$emit(&#x27;setAlert&#x27;, &#x27;success&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.RETRY_SUCCESS&#x27;), 4000);
          reload();
        });
    }

    /**
     * Asks server to start uploading the media to the chosen platform.
     *
     * @param {Array} medias The list of medias to work on
     * @param {String} platformName The name of platform to upload to
     * @param {Function} reload Function to reload the datatable
     */
    function startMediaUpload(medias, platformName, reload) {
      publishService.startMediaUpload(medias.join(&#x27;,&#x27;), platformName)
        .then(function() {
          $scope.$emit(&#x27;setAlert&#x27;, &#x27;success&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.UPLOAD_START_SUCCESS&#x27;), 4000);
          reload();
        });
    }

    /**
     * Publishes a list of medias.
     *
     * @param {Array} medias The list of media ids to publish
     * @param {Function} reload Function to reload the datatable
     */
    function publishMedia(medias, reload) {
      publishService.publishMedia(medias.join(&#x27;,&#x27;))
        .then(function() {
          $scope.$emit(&#x27;setAlert&#x27;, &#x27;success&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.PUBLISHED_SUCCESS&#x27;), 4000);
          reload();
        });
    }

    /**
     * Unpublishes a list of medias.
     *
     * @param {Array} medias The list of media ids to unpublish
     * @param {Function} reload Function to reload the datatable
     */
    function unpublishMedia(medias, reload) {
      publishService.unpublishMedia(medias.join(&#x27;,&#x27;))
        .then(function() {
          $scope.$emit(&#x27;setAlert&#x27;, &#x27;success&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.UNPUBLISHED_SUCCESS&#x27;), 4000);
          reload();
        });
    }

    /**
     * Removes a list of medias.
     *
     * @param {Array} selected The list of media ids to remove
     * @param {Function} reload Function to reload the datatable
     */
    function removeRows(selected, reload) {
      entityService.removeEntities(entityType, publishName, selected.join(&#x27;,&#x27;))
        .then(function() {
          $scope.$emit(&#x27;setAlert&#x27;, &#x27;success&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.REMOVE_SUCCESS&#x27;), 4000);
          reload();
        });
    }

    /**
     * Saves media information.
     *
     * @param {Object} media Media data
     */
    function saveMedia(media) {
      var customProperties = {};

      for (var id in media.customProperties) {
        var value = media.customProperties[id];
        customProperties[id] = (value instanceof Date) ? value.getTime() : value;
      }

      return publishService.updateMedia(media.id, {
        title: media.title,
        date: media.date.getTime(),
        leadParagraph: media.leadParagraph,
        description: media.description,
        thumbnail: $scope.thumbToEdit,
        properties: customProperties,
        category: media.category,
        groups: media.groups,
        user: media.user
      }).then(function() {
        scopeEditForm.pendingEdition = false;
      });
    }

    /**
     * Routes to media editor.
     *
     * @param {Object} media The media to edit
     */
    function mediaEditor(media) {
      $location.path(&#x27;/publish/media/&#x27; + media.id);
    }

    /**
     * Builds custom properties fields descriptors for formly.
     *
     * @param {Object} [model] Model where to find default values
     * @param {Boolean} [inlineEditable] true to generate an inline editable field instead of a simple editable field
     * @return {Array} The list of formly fields descriptors
     */
    function getCustomPropertiesFields(model, inlineEditable) {
      var fields = [];

      angular.forEach($scope.properties, function(property, index) {
        if (property.type === &#x27;text&#x27;) {
          fields.push({
            key: property.id,
            type: inlineEditable ? &#x27;horizontalEditableInput&#x27; : &#x27;horizontalInput&#x27;,
            model: model,
            templateOptions: {
              label: property.name || property.id
            }
          });

        } else if (property.type === &#x27;list&#x27;) {

          // Build list options with list values
          var options = [{
            value: null,
            name: $filter(&#x27;translate&#x27;)(&#x27;CORE.UI.EMPTY&#x27;)
          }];

          for (var i = 0; i &lt; property.values.length; i++) {
            options.push({
              value: property.values[i],
              name: property.values[i]
            });
          }

          fields.push({
            key: property.id,
            type: inlineEditable ? &#x27;horizontalEditableSelect&#x27; : &#x27;horizontalSelect&#x27;,
            model: model,
            defaultValue: options[0].value,
            templateOptions: {
              label: property.name || property.id,
              options: options
            }
          });
        } else if (property.type === &#x27;boolean&#x27;) {
          fields.push({
            key: property.id,
            type: inlineEditable ? &#x27;horizontalEditableCheckbox&#x27; : &#x27;horizontalCheckbox&#x27;,
            defaultValue: false,
            model: model,
            templateOptions: {
              label: property.name || property.id
            }
          });
        } else if (property.type === &#x27;dateTime&#x27;) {
          model[property.id] = model[property.id] &amp;&amp; new Date(model[property.id]);
          fields.push({
            key: property.id,
            type: inlineEditable ? &#x27;horizontalEditableDateTimePicker&#x27; : &#x27;horizontalDateTimePicker&#x27;,
            model: model,
            templateOptions: {
              label: property.name || property.id
            }
          });
        }
      });

      return fields;
    }

    // Setup add form
    scopeAddForm.fields = [
      {
        key: &#x27;title&#x27;,
        type: &#x27;horizontalInput&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_TITLE&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_TITLE_DESC&#x27;),
          required: true
        }
      },
      {
        key: &#x27;date&#x27;,
        type: &#x27;horizontalDateTimePicker&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_DATE&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_DATE_DESC&#x27;),
          required: true
        }
      },
      {
        key: &#x27;leadParagraph&#x27;,
        type: &#x27;horizontalTinymce&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_LEAD_PARAGRAPH&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_LEAD_PARAGRAPH_DESC&#x27;)
        },
        data: {
          tinymceOptions: tinyOptions
        }
      },
      {
        key: &#x27;description&#x27;,
        type: &#x27;horizontalTinymce&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_DESCRIPTION&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_DESCRIPTION_DESC&#x27;)
        },
        data: {
          tinymceOptions: tinyOptions
        }
      },
      {
        key: &#x27;file&#x27;,
        type: &#x27;horizontalFile&#x27;,
        defaultValue: -1,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_MEDIA&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_MEDIA_DESC&#x27;),
          acceptedTypes: &#x27;.mp4,.tar&#x27;,
          required: true,
          progressBar: false,
          onFileChange: function(files, file, newFiles, duplicateFiles, invalidFiles, event) {
            $scope.fileToUpload = file;
          }
        }
      },
      {
        key: &#x27;thumbnail&#x27;,
        type: &#x27;horizontalFile&#x27;,
        defaultValue: -1,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_THUMBNAIL&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_THUMBNAIL_DESC&#x27;),
          acceptedTypes: &#x27;.jpeg,.jpg&#x27;,
          required: false,
          progressBar: false,
          onFileChange: function(files, file, newFiles, duplicateFiles, invalidFiles, event) {
            $scope.thumbToAdd = file;
          }
        }
      },
      {
        key: &#x27;category&#x27;,
        type: &#x27;horizontalSelect&#x27;,
        defaultValue: null,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_CATEGORY&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_CATEGORY_DESC&#x27;),
          options: getSelectableCategories(&#x27;CORE.UI.NONE&#x27;)
        }
      },
      {
        key: &#x27;groups&#x27;,
        type: &#x27;horizontalSelect&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_GROUPS&#x27;),
          description: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.FORM_ADD_GROUPS_DESC&#x27;),
          options: utilService.buildSelectOptions($scope.groups)
        },
        ngModelAttrs: {
          &#x27;true&#x27;: {
            value: &#x27;multiple&#x27;
          }
        }
      }
    ];

    // Separator between built-in properties and custom properties
    if ($scope.properties.length) {
      scopeAddForm.fields.push({
        noFormControl: true,
        template: &#x27;&lt;hr&gt;&#x27;
      });
    }

    // Custom properties
    scopeAddForm.fields = scopeAddForm.fields.concat(getCustomPropertiesFields(scopeAddForm.model.properties));

    /**
     * Collapses / extends the add form.
     */
    $scope.toggleAddForm = function() {
      $scope.isCollapsed = !$scope.isCollapsed;
    };

    scopeAddForm.onSubmit = function(model) {
      var groups = [];
      var customProperties = {};

      // Remove group &quot;null&quot; from the list of selected groups
      if (model.groups) {
        groups = model.groups.filter(function(group) {
          return group;
        });
      }

      for (var id in model.properties) {
        var value = model.properties[id];
        customProperties[id] = (value instanceof Date) ? value.getTime() : value;
      }

      addMediaPromise = publishService.addMedia({
        title: model.title,
        date: model.date.getTime(),
        leadParagraph: model.leadParagraph,
        description: model.description,
        category: model.category,
        groups: groups,
        file: $scope.fileToUpload,
        thumbnail: $scope.thumbToAdd,
        properties: customProperties
      });

      return addMediaPromise.then(function() {
        entityService.deleteCache(entityType, publishName);
        addMediaPromise = null;
        $scope.isCollapsed = true;
      }, function() {
        addMediaPromise = null;
        model.file = null;
        return $q.reject();
      }, function(event) {

        // Update progress bar
        model.file = Math.min(100, parseInt(100.0 * event.loaded / event.total));

      });
    };

    // Setup edit form
    scopeEditForm.entityType = entityType;
    scopeEditForm.fieldsBase = [
      {
        key: &#x27;title&#x27;,
        type: &#x27;horizontalEditableInput&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_TITLE&#x27;),
          required: true
        }
      },
      {
        key: &#x27;date&#x27;,
        type: &#x27;horizontalEditableDateTimePicker&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_DATE&#x27;),
          required: true
        }
      },
      {
        key: &#x27;leadParagraph&#x27;,
        type: &#x27;horizontalEditableTinymce&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_LEAD_PARAGRAPH&#x27;)
        },
        data: {
          tinymceOptions: tinyOptions
        }
      },
      {
        key: &#x27;description&#x27;,
        type: &#x27;horizontalEditableTinymce&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_DESCRIPTION&#x27;)
        },
        data: {
          tinymceOptions: tinyOptions
        }
      },
      {
        key: &#x27;thumbnail&#x27;,
        type: &#x27;horizontalEditableFile&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_THUMBNAIL&#x27;),
          acceptedTypes: &#x27;.jpeg,.jpg&#x27;,
          required: false,
          progressBar: false,
          onFileChange: function(files, file, newFiles, duplicateFiles, invalidFiles, event) {
            $scope.thumbToEdit = file;
          }
        },
        link: function(scope, element, attrs) {
          var ts = Date.now();

          scope.show = function() {
            if (!scope.originalModel.thumbnail)
              return $filter(&#x27;translate&#x27;)(&#x27;CORE.UI.EMPTY&#x27;);

            var src = scope.originalModel.thumbnail;
            src = OvUrlFactory.setUrlParameter(scope.originalModel.thumbnail, &#x27;style&#x27;, &#x27;publish-thumb-200&#x27;);

            // Workaround: add timestamp to src
            // As the URL don&#x27;t change even if a new thumbnail is submitted,
            // adding this parameter will force regeneration of the tag.
            src = OvUrlFactory.setUrlParameter(src, &#x27;ts&#x27;, ts);

            return &#x27;&lt;img class=&quot;img-thumbnail&quot; src=&quot;&#x27; + src + &#x27;&quot;&gt;&#x27;;
          };
        }
      },
      {
        key: &#x27;category&#x27;,
        type: &#x27;horizontalEditableSelect&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_CATEGORY&#x27;),
          options: getSelectableCategories(&#x27;CORE.UI.NONE&#x27;)
        }
      },
      {
        key: &#x27;groups&#x27;,
        type: &#x27;horizontalEditableSelect&#x27;,
        templateOptions: {
          label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_GROUPS&#x27;),
          options: utilService.buildSelectOptions($scope.groups)
        },
        ngModelAttrs: {
          &#x27;true&#x27;: {
            value: &#x27;multiple&#x27;
          }
        }
      }
    ];

    // Setup datatable
    scopeDataTable.entityType = entityType;
    scopeDataTable.cellTheme = &#x27;/publish/be/views/partial/publishCells.html&#x27;;

    scopeDataTable.init = {
      sortBy: &#x27;date&#x27;,
      sortOrder: &#x27;dsc&#x27;,
      notSortBy: [&#x27;mediaId&#x27;]
    };
    scopeDataTable.filterBy = [
      {
        key: &#x27;query&#x27;,
        value: &#x27;&#x27;,
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.QUERY_FILTER&#x27;)
      }, {
        key: &#x27;dateStart&#x27;,
        type: &#x27;date&#x27;,
        value: &#x27;&#x27;,
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.START_DATE_FILTER&#x27;),
        getValue: function(value) {
          return value.getTime();
        }
      }, {
        key: &#x27;dateEnd&#x27;,
        type: &#x27;date&#x27;,
        value: &#x27;&#x27;,
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.END_DATE_FILTER&#x27;),
        getValue: function(value) {
          value.setDate(value.getDate() + 1);
          value.setMilliseconds(value.getMilliseconds() - 1);
          return value.getTime();
        }
      }, {
        key: &#x27;categories&#x27;,
        type: &#x27;select&#x27;,
        value: null,
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.CATEGORY_FILTER&#x27;),
        options: getSelectableCategories(&#x27;CORE.UI.ALL&#x27;)
      }, {
        key: &#x27;user&#x27;,
        type: &#x27;autoComplete&#x27;,
        value: null,
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.OWNER_FILTER&#x27;),
        getValue: function(suggestion) {
          return (suggestion &amp;&amp; suggestion.value) || null;
        },
        getSuggestions: function(query) {
          if (userFilterCanceller) {

            // Hack to differentiate cancel from unavailable server and then avoid a notification
            userFilterCanceller.promise.status = true;
            userFilterCanceller.resolve();

          }
          userFilterCanceller = $q.defer();

          return entityService.getAllEntities(&#x27;users&#x27;, null, {
            include: [&#x27;id&#x27;, &#x27;name&#x27;],
            sortBy: &#x27;name&#x27;,
            sortOrder: &#x27;asc&#x27;,
            query: query,
            useSmartSearch: 0
          }, userFilterCanceller.promise).then(function(results) {
            var suggestions = [];
            results.data.entities.forEach(function(user) {
              suggestions.push(
                {
                  value: user.id,
                  name: user.name
                }
              );
            });
            return $q.when(suggestions);
          });
        }
      }
    ];
    scopeDataTable.header = [
      {
        key: &#x27;title&#x27;,
        name: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.NAME_COLUMN&#x27;),
        class: [&#x27;col-xs-8 col-sm-5&#x27;]
      },
      {
        key: &#x27;mediaId&#x27;,
        type: &#x27;multisources&#x27;,
        name: &#x27;&#x27;,
        class: [&#x27;hidden-xs col-sm-1&#x27;]
      },
      {
        key: &#x27;date&#x27;,
        type: &#x27;date&#x27;,
        name: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.DATE_COLUMN&#x27;),
        class: [&#x27;col-xs-1&#x27;]
      },
      {
        key: &#x27;category&#x27;,
        type: &#x27;category&#x27;,
        name: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.CATEGORY_COLUMN&#x27;),
        class: [&#x27;hidden-xs col-sm-2&#x27;]
      },
      {
        key: &#x27;state&#x27;,
        type: &#x27;status&#x27;,
        name: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.STATUS_COLUMN&#x27;),
        class: [&#x27;col-xs-2&#x27;]
      },
      {
        key: &#x27;action&#x27;,
        name: $filter(&#x27;translate&#x27;)(&#x27;CORE.UI.ACTIONS_COLUMN&#x27;),
        class: [&#x27;col-xs-1 col-sm-1&#x27;]
      }];
    scopeDataTable.actions = [
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;CORE.UI.VIEW&#x27;),
        condition: function(row) {
          return row.state == 11 || row.state == 12;
        },
        callback: function(row) {
          goToPath(row.link + &#x27;?lang=&#x27; + i18nService.getLanguage());
        }
      },
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;CORE.UI.SHARE&#x27;),
        condition: function(row) {
          return row.state == 12;
        },
        callback: function(row) {
          shareCode(row);
        }
      },
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.PUBLISH&#x27;),
        condition: function(row) {
          return $scope.rights.publish &amp;&amp;
            ($scope.checkContentAccess(row, &#x27;update&#x27;) || isUserManager) &amp;&amp;
            row.state == 11 &amp;&amp;
            !row.saving;
        },
        callback: function(row, reload) {
          publishMedia([row.id], reload);
        },
        global: function(selected, reload) {
          publishMedia(selected, reload);
        }
      },
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.UNPUBLISH&#x27;),
        condition: function(row) {
          return $scope.rights.publish &amp;&amp;
            ($scope.checkContentAccess(row, &#x27;update&#x27;) || isUserManager) &amp;&amp;
            row.state == 12 &amp;&amp;
            !row.saving;
        },
        callback: function(row, reload) {
          unpublishMedia([row.id], reload);
        },
        global: function(selected, reload) {
          unpublishMedia(selected, reload);
        }
      },
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.CHAPTER_EDIT&#x27;),
        condition: function(row) {
          return $scope.rights.editor &amp;&amp;
            ($scope.checkContentAccess(row, &#x27;update&#x27;) || isUserManager) &amp;&amp;
            !row.saving &amp;&amp;
            (row.state == 11 || row.state == 12);
        },
        callback: function(row) {
          mediaEditor(row);
        }
      },
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.RETRY&#x27;),
        condition: function(row) {
          return $scope.rights.retry &amp;&amp;
            ($scope.checkContentAccess(row, &#x27;update&#x27;) || isUserManager) &amp;&amp;
            row.state == 0 &amp;&amp;
            !row.saving;
        },
        callback: function(row, reload) {
          retryMedia([row.id], reload);
        }
      },
      {
        label: $filter(&#x27;translate&#x27;)(&#x27;CORE.UI.REMOVE&#x27;),
        condition: function(row) {
          return $scope.rights.remove &amp;&amp;
            ($scope.checkContentAccess(row, &#x27;delete&#x27;) || isUserManager) &amp;&amp;
            !row.locked &amp;&amp;
            !row.saving &amp;&amp;
            (row.state === 6 || row.state === 11 || row.state === 12 || row.state === 0);
        },
        warningPopup: true,
        callback: function(row, reload) {
          removeRows([row.id], reload);
        },
        global: function(selected, reload) {
          removeRows(selected, reload);
        }
      }
    ];

    // Add upload actions
    for (var i = 0; i &lt; $scope.platforms.length; i++) {
      var platformName = $scope.platforms[i];
      scopeDataTable.actions.push({
        label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.UPLOAD_&#x27; + platformName.toUpperCase()),
        condition: function(row) {
          return $scope.rights.upload &amp;&amp;
            ($scope.checkContentAccess(row, &#x27;update&#x27;) || isUserManager) &amp;&amp;
            row.state == 6 &amp;&amp;
            !row.saving;
        },
        callback: function(row, reload) {
          startMediaUpload([row.id], this.platform, reload);
        },
        platform: platformName
      });
    }

    scopeEditForm.init = function(row) {
      var properties = {};
      scopeEditForm.fields = angular.copy(scopeEditForm.fieldsBase);
      if (!row.mediaId)
        scopeEditForm.fields = scopeEditForm.fields.filter(function(field) {
          return field.key !== &#x27;thumbnail&#x27;;
        });

      row.groups = row.metadata.groups;
      row.user = row.metadata.user;
      row.date = new Date(row.date);

      // Build properties
      for (var propertyId in row.properties) {
        if (row.properties[propertyId])
          properties[propertyId] = row.properties[propertyId].value || null;
      }

      row.customProperties = properties;

      // User field
      if (row.metadata.user == $scope.userInfo.id ||
        $scope.userInfo.id == openVeoSettings.superAdminId ||
        isUserManager
      ) {
        var opt = utilService.buildSelectOptions($scope.users);
        scopeEditForm.fields.push({
          key: &#x27;user&#x27;,
          type: &#x27;horizontalEditableSelect&#x27;,
          templateOptions: {
            label: $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.ATTR_OWNER&#x27;),
            options: opt
          }
        });
      }

      // Separator between built-in properties and custom properties
      if ($scope.properties.length) {
        scopeEditForm.fields.push({
          noFormControl: true,
          template: &#x27;&lt;hr&gt;&#x27;
        });
      }

      scopeEditForm.fields = scopeEditForm.fields.concat(getCustomPropertiesFields(row.customProperties, true));
    };

    scopeEditForm.conditionToggleDetail = function(row) {
      return row.state !== 0;
    };

    scopeEditForm.conditionEditDetail = function(row) {
      return $scope.rights.update &amp;&amp;
        ($scope.checkContentAccess(row, &#x27;update&#x27;) || isUserManager) &amp;&amp;
        !row.locked &amp;&amp;
        row.state !== 0;
    };
    scopeEditForm.onSubmit = function(model) {
      return saveMedia(model);
    };

    // Listen to destroy event on the view to update
    $scope.$on(&#x27;$destroy&#x27;, function() {
      $interval.cancel(pollMediasPromise);

      // Abort upload if any
      if (addMediaPromise) {
        addMediaPromise.abort();
        $scope.$emit(&#x27;setAlert&#x27;, &#x27;warning&#x27;, $filter(&#x27;translate&#x27;)(&#x27;PUBLISH.MEDIAS.UPLOAD_CANCELED&#x27;), 4000);
      }
    });
  }

  app.controller(&#x27;MediaController&#x27;, MediaController);
  MediaController.$inject = [
    &#x27;$scope&#x27;,
    &#x27;$filter&#x27;,
    &#x27;$location&#x27;,
    &#x27;$window&#x27;,
    &#x27;$interval&#x27;,
    &#x27;$q&#x27;,
    &#x27;entityService&#x27;,
    &#x27;publishService&#x27;,
    &#x27;utilService&#x27;,
    &#x27;properties&#x27;,
    &#x27;platforms&#x27;,
    &#x27;groups&#x27;,
    &#x27;users&#x27;,
    &#x27;settings&#x27;,
    &#x27;tableReloadEventService&#x27;,
    &#x27;i18nService&#x27;,
    &#x27;publishName&#x27;,
    &#x27;OvUrlFactory&#x27;
  ];

})(angular.module(&#x27;ov.publish&#x27;));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
