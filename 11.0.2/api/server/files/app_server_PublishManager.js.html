<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>app/server/PublishManager.js - OpenVeo Publish server</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">OpenVeo Publish server</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 11.0.2
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ConfigurationController.html">ConfigurationController</a></li>
                                <li><a href="../classes/DirectoryFsWatcher.html">DirectoryFsWatcher</a></li>
                                <li><a href="../classes/DirectoryWatcher.html">DirectoryWatcher</a></li>
                                <li><a href="../classes/ERRORS.html">ERRORS</a></li>
                                <li><a href="../classes/factory.html">factory</a></li>
                                <li><a href="../classes/GoogleOAuthHelper.html">GoogleOAuthHelper</a></li>
                                <li><a href="../classes/HTTP_ERRORS.html">HTTP_ERRORS</a></li>
                                <li><a href="../classes/listener.html">listener</a></li>
                                <li><a href="../classes/LocalProvider.html">LocalProvider</a></li>
                                <li><a href="../classes/mediaPlatformFactory.html">mediaPlatformFactory</a></li>
                                <li><a href="../classes/MediaPlatformProvider.html">MediaPlatformProvider</a></li>
                                <li><a href="../classes/Package.html">Package</a></li>
                                <li><a href="../classes/PackageError.html">PackageError</a></li>
                                <li><a href="../classes/PoiProvider.html">PoiProvider</a></li>
                                <li><a href="../classes/PropertyController.html">PropertyController</a></li>
                                <li><a href="../classes/PropertyProvider.html">PropertyProvider</a></li>
                                <li><a href="../classes/PUBLISH_HOOKS.html">PUBLISH_HOOKS</a></li>
                                <li><a href="../classes/PublishError.html">PublishError</a></li>
                                <li><a href="../classes/PublishManager.html">PublishManager</a></li>
                                <li><a href="../classes/PublishPlugin.html">PublishPlugin</a></li>
                                <li><a href="../classes/PublishPluginApi.html">PublishPluginApi</a></li>
                                <li><a href="../classes/ResumableUpload.html">ResumableUpload</a></li>
                                <li><a href="../classes/STATES.html">STATES</a></li>
                                <li><a href="../classes/StatisticsController.html">StatisticsController</a></li>
                                <li><a href="../classes/TarPackage.html">TarPackage</a></li>
                                <li><a href="../classes/TarPackageError.html">TarPackageError</a></li>
                                <li><a href="../classes/TlsClient.html">TlsClient</a></li>
                                <li><a href="../classes/TlsProvider.html">TlsProvider</a></li>
                                <li><a href="../classes/TYPES.html">TYPES</a></li>
                                <li><a href="../classes/VideoController.html">VideoController</a></li>
                                <li><a href="../classes/VideoPackage.html">VideoPackage</a></li>
                                <li><a href="../classes/VideoPackageError.html">VideoPackageError</a></li>
                                <li><a href="../classes/VideoProvider.html">VideoProvider</a></li>
                                <li><a href="../classes/VimeoProvider.html">VimeoProvider</a></li>
                                <li><a href="../classes/Watcher.html">Watcher</a></li>
                                <li><a href="../classes/WatcherError.html">WatcherError</a></li>
                                <li><a href="../classes/WowzaProvider.html">WowzaProvider</a></li>
                                <li><a href="../classes/YoutubeProvider.html">YoutubeProvider</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/controllers.html">controllers</a></li>
                                <li><a href="../modules/packages.html">packages</a></li>
                                <li><a href="../modules/providers.html">providers</a></li>
                                <li><a href="../modules/publish.html">publish</a></li>
                                <li><a href="../modules/watcher.html">watcher</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/server/PublishManager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
 * @module publish
 */

var util = require(&#x27;util&#x27;);
var events = require(&#x27;events&#x27;);
var path = require(&#x27;path&#x27;);
var shortid = require(&#x27;shortid&#x27;);
var openVeoApi = require(&#x27;@openveo/api&#x27;);
var Package = process.requirePublish(&#x27;app/server/packages/Package.js&#x27;);
var packageFactory = process.requirePublish(&#x27;app/server/packages/packageFactory.js&#x27;);
var ERRORS = process.requirePublish(&#x27;app/server/packages/errors.js&#x27;);
var STATES = process.requirePublish(&#x27;app/server/packages/states.js&#x27;);
var PublishError = process.requirePublish(&#x27;app/server/PublishError.js&#x27;);
var ResourceFilter = openVeoApi.storages.ResourceFilter;

var publishManager;

/**
 * Fired when an error occurred while processing a package.
 *
 * @event error
 * @param {Error} The error
 */

/**
 * Fired when a package process has succeed.
 *
 * @event complete
 * @param {Object} The processed package
 */

/**
 * Fired when a media in error restarts.
 *
 * @event retry
 * @param {Object} The media
 */

/**
 * Fired when a media stuck in &quot;waiting for upload&quot; state starts uploading.
 *
 * @event upload
 * @param {Object} The media
 */

/**
 * Fired when media state has changed.
 *
 * @event stateChanged
 * @param {Object} The media
 */

/**
 * Defines the PublishManager which handles the media publication&#x27;s process.
 *
 * Media publications are handled in parallel. Media publication&#x27;s process can be
 * different regarding the type of the media.
 *
 * @example
 *     var coreApi = process.api.getCoreApi();
 *     var database = coreApi.getDatabase();
 *     var PublishManager = process.requirePublish(&#x27;app/server/PublishManager.js&#x27;);
 *     var videoProvider = new VideoProvider(database);
 *     var publishManager = new PublishManager(videoProvider, 5);
 *
 *     // Listen publish manager&#x27;s errors
 *     publishManager.on(&#x27;error&#x27;, function(error) {
 *       // Do something
 *     });
 *
 *     // Listen to publish manager&#x27;s end of processing for a media
 *     publishManager.on(&#x27;complete&#x27;, function(mediaPackage){
 *       // Do something
 *     });
 *
 *     // Listen to publish manager&#x27;s event informing that a media processing is retrying
 *     publishManager.on(&#x27;retry&#x27;, function(mediaPackage) {
 *       // Do something
 *     });
 *
 *     // Listen to publish manager&#x27;s event informing that a media, waiting for upload, starts uploading
 *     publishManager.on(&#x27;upload&#x27;, function(mediaPackage) {
 *       // Do something
 *     });
 *
 *     publishManager.publish({
 *       type: &#x27;youtube&#x27;, // The media platform to use for this media
 *       originalPackagePath: &#x27;/home/openveo/medias/media-package.tar&#x27;, // Path of the media package
 *       originalFileName: &#x27;media-package&#x27; // File name without extension
 *     });
 *
 * @class PublishManager
 * @constructor
 * @param {VideoProvider} videoProvider The media provider
 * @param {Number} [maxConcurrentPackage=3] The maximum number of medias to treat in parallel
 */
function PublishManager(videoProvider, maxConcurrentPackage) {
  if (publishManager)
    throw new Error(&#x27;PublishManager already instanciated, use get method instead&#x27;);

  Object.defineProperties(this, {

    /**
     * Medias waiting to be processed.
     *
     * @property queue
     * @type Array
     * @final
     */
    queue: {value: []},

    /**
     * Medias being processed.
     *
     * @property pendingPackages
     * @type Array
     * @final
     */
    pendingPackages: {value: []},

    /**
     * Media provider.
     *
     * @property videoProvider
     * @type VideoProvider
     * @final
     */
    videoProvider: {value: videoProvider},

    /**
     * Maximum number of medias to treat in parallel.
     *
     * @property maxConcurrentPackage
     * @type Number
     * @final
     */
    maxConcurrentPackage: {value: maxConcurrentPackage || 3}

  });
}

util.inherits(PublishManager, events.EventEmitter);
module.exports = PublishManager;

/**
 * Removes a media from pending medias.
 *
 * @method removeFromPending
 * @private
 * @param {Object} mediaPackage The media package to remove
 */
function removeFromPending(mediaPackage) {
  for (var i = 0; i &lt; this.pendingPackages.length; i++) {
    if (this.pendingPackages[i][&#x27;id&#x27;] === mediaPackage.id) {
      this.pendingPackages.splice(i, 1);
      break;
    }
  }
  for (var j = 0; j &lt; this.pendingPackages.length; j++) {
    if (this.pendingPackages[j][&#x27;originalFileName&#x27;] === mediaPackage.originalFileName) {
      this.pendingPackages.splice(j, 1);
      break;
    }
  }
  process.logger.debug(&#x27;Package &#x27; + mediaPackage.id + &#x27; from &#x27; +
   mediaPackage.originalFileName + &#x27; is removed from pendingPackages&#x27;);
}

/**
 * Handles media error event.
 *
 * @method onError
 * @private
 * @param {Error} error The error
 * @param {Object} mediaPackage The media on error
 */
function onError(error, mediaPackage) {

  // Remove media from pending medias
  removeFromPending.call(this, mediaPackage);

  // Publish pending media from FIFO queue
  if (this.queue.length)
    this.publish(this.queue.shift(0));

  // Add media id to the error message
  if (error)
    error.message += &#x27; (&#x27; + mediaPackage.id + &#x27;)&#x27;;

  this.emit(&#x27;error&#x27;, error, error.code);
}

/**
 * Handles media complete event.
 *
 * @method onComplete
 * @private
 * @param {Object} mediaPackage The package on error
 */
function onComplete(mediaPackage) {

  // Remove package from pending packages
  removeFromPending.call(this, mediaPackage);

  // Publish pending package from FIFO queue
  if (this.queue.length)
    this.publish(this.queue.shift(0));

  this.emit(&#x27;complete&#x27;, mediaPackage);
}

/**
 * Creates a media package manager corresponding to the media type.
 *
 * @method createMediaPackageManager
 * @private
 * @param {Object} mediaPackage The media to manage
 * @return {Package} A media package manager
 */
function createMediaPackageManager(mediaPackage) {
  var self = this;
  var mediaPackageManager = packageFactory.get(mediaPackage.packageType, mediaPackage);

  // Handle errors from media package manager
  mediaPackageManager.on(&#x27;error&#x27;, function(error) {
    onError.call(self, error, mediaPackage);
  });

  // Handle complete events from media package manager
  mediaPackageManager.on(&#x27;complete&#x27;, function(completePackage) {
    onComplete.call(self, completePackage);
  });

  // Handle stateChanged events from media package manager
  mediaPackageManager.on(&#x27;stateChanged&#x27;, function(mediaPackage) {
    self.emit(&#x27;stateChanged&#x27;, mediaPackage);
  });

  return mediaPackageManager;
}

/**
 * Adds media package to the list of pending packages.
 *
 * @method addPackage
 * @private
 * @param {Object} mediaPackage The media package to add to pending packages
 * @return {Boolean} true if the media package is successfully added to pending packages
 * false if it has been added to queue
 */
function addPackage(mediaPackage) {
  process.logger.debug(&#x27;Actually &#x27; + this.pendingPackages.length + &#x27; pending packages&#x27;);
  var idAllreadyPending = this.pendingPackages.filter(function(pendingPackage) {
    return mediaPackage.originalFileName === pendingPackage.originalFileName;
  });

  // Too much pending packages
  if (this.pendingPackages.length &gt;= this.maxConcurrentPackage || idAllreadyPending.length) {

    // Add package to queue
    this.queue.push(mediaPackage);
    process.logger.debug(&#x27;Add package &#x27; + mediaPackage.originalPackagePath + &#x27;(&#x27; + mediaPackage.id + &#x27;) to queue&#x27;);
    return false;
  } else {

    // Process can deal with the package
    process.logger.debug(&#x27;Add package &#x27; + mediaPackage.originalPackagePath +
                      &#x27;(&#x27; + mediaPackage.id + &#x27;) to pending packages&#x27;);

    // Add package to the list of pending packages
    this.pendingPackages.push(mediaPackage);
    return true;
  }
}

/**
 * Gets an instance of the PublishManager.
 *
 * @method get
 * @static
 * @param {VideoProvider} videoProvider The media provider
 * @param {Number} [maxConcurrentPackage] The maximum number of medias to treat in parallel
 * @return {PublishManager} The PublishManager singleton instance
 */
PublishManager.get = function(videoProvider, maxConcurrentPackage) {
  if (!publishManager)
    publishManager = new PublishManager(videoProvider);

  return publishManager;
};

/**
 * Publishes the given media package.
 *
 * Media package must be of one of the supported type.
 *
 * @method publish
 * @param {Object} mediaPackage Media to publish
 * @param {String} mediaPackage.originalPackagePath Package absolute path
 * @param {String} mediaPackage.packageType The package type
 * @param {String} [mediaPackage.title] The title to use for this media, default to the file name without extension
 */
PublishManager.prototype.publish = function(mediaPackage) {
  var self = this;

  if (mediaPackage &amp;&amp; (typeof mediaPackage === &#x27;object&#x27;)) {

    // Media package can be in queue and already have an id
    if (!mediaPackage.id) {
      var pathDescriptor = path.parse(mediaPackage.originalPackagePath);
      mediaPackage.id = shortid.generate();
      mediaPackage.title = mediaPackage.title || pathDescriptor.name;
    }

    self.videoProvider.getOne(
      new ResourceFilter().equal(&#x27;originalPackagePath&#x27;, mediaPackage.originalPackagePath),
      {
        include: [&#x27;id&#x27;]
      },
      function(error, media) {
        if (error) {
          self.emit(&#x27;error&#x27;, new PublishError(&#x27;Getting media with original package path &quot;&#x27; +
                                              mediaPackage.originalPackagePath + &#x27;&quot; failed with message : &#x27; +
                                              error.message, ERRORS.UNKNOWN));
        } else if (!media) {

          // Package can be added to pending packages as a new one
          if (addPackage.call(self, mediaPackage)) {

            // Media package does not exist
            // Publish it
            var mediaPackageManager = createMediaPackageManager.call(self, mediaPackage);
            mediaPackageManager.init(Package.STATES.PACKAGE_SUBMITTED, Package.TRANSITIONS.INIT);
            mediaPackageManager.executeTransition(Package.TRANSITIONS.INIT);

          }

        } else if (media.id === mediaPackage.id) {

          // Media already exists
          // Retry media
          self.retry(media.id, true);

        } else {
          self.emit(
            &#x27;error&#x27;,
            new PublishError(&#x27;Duplicate file &quot;&#x27; + mediaPackage.originalPackagePath, ERRORS.DUPLICATE_MEDIA)
          );
        }
      }
    );
  } else
    this.emit(&#x27;error&#x27;, new PublishError(&#x27;mediaPackage argument must be an Object&#x27;, ERRORS.UNKNOWN));
};

/**
 * Retries publishing a media package which is on error.
 *
 * @method retry
 * @param {String} packageId The id of the package on error
 * @param {Boolean} forceRetry Force retrying a package no matter its state
 */
PublishManager.prototype.retry = function(packageId, forceRetry) {
  if (packageId) {
    var self = this;

    // Retrieve package information
    this.videoProvider.getOne(
      new ResourceFilter().equal(&#x27;id&#x27;, packageId),
      null,
      function(error, mediaPackage) {
        if (error) {
          self.emit(
            &#x27;error&#x27;,
            new PublishError(
              &#x27;Getting package &#x27; + packageId + &#x27; failed with message : &#x27; + error.message,
              ERRORS.UNKNOWN
            )
          );
        } else if (!mediaPackage) {

          // Package does not exist
          self.emit(
            &#x27;error&#x27;,
            new PublishError(&#x27;Cannot retry package &#x27; + packageId + &#x27; (not found)&#x27;, ERRORS.PACKAGE_NOT_FOUND)
          );

        } else if (mediaPackage.state === STATES.ERROR || forceRetry) {

          // Got package information
          // Package is indeed in error
          self.videoProvider.updateState(mediaPackage.id, STATES.PENDING, function() {

            // Retry officially started
            self.emit(&#x27;retry&#x27;, mediaPackage);
            self.emit(&#x27;stateChanged&#x27;, mediaPackage);

          });

          var mediaPackageManager = createMediaPackageManager.call(self, mediaPackage);
          process.logger.info(&#x27;Retry package &#x27; + mediaPackage.id);
          mediaPackageManager.init(mediaPackage.lastState, mediaPackage.lastTransition);

          // Package can be added to pending packages
          if (addPackage.call(self, mediaPackage))
            mediaPackageManager.executeTransition(mediaPackage.lastTransition);
        }

      }
    );
  }
};

/**
 * Retries publishing all packages in a non stable state.
 *
 * Stable states are :
 * - STATES.ERROR
 * - STATES.WAITING_FOR_UPLOAD
 * - STATES.READY
 * - STATES.PUBLISHED
 *
 * @method retryAll
 */
PublishManager.prototype.retryAll = function() {
  var self = this;

  // Retrieve all packages in a non stable state
  this.videoProvider.getAll(
    new ResourceFilter().notIn(
      &#x27;state&#x27;, [
        STATES.ERROR,
        STATES.WAITING_FOR_UPLOAD,
        STATES.READY,
        STATES.PUBLISHED
      ]
    ),
    null,
    {
      id: &#x27;desc&#x27;
    },
    function(error, mediaPackages) {
      if (error) {
        return self.emit(
          &#x27;error&#x27;,
          new PublishError(
            &#x27;Getting packages in non stable state failed with message : &#x27; + error.message,
            ERRORS.UNKNOWN
          )
        );
      }

      mediaPackages.forEach(function(mediaPackage) {
        self.retry(mediaPackage.id, true);
      });

    }
  );

};

/**
 * Uploads a media blocked in &quot;waiting to upload&quot; state.
 *
 * @method upload
 * @param {String} packageId The id of the package waiting to be uploaded
 * @param {String} platform The type of the video platform to upload to
 */
PublishManager.prototype.upload = function(packageId, platform) {
  if (packageId &amp;&amp; platform) {
    var self = this;

    // Retrieve package information
    this.videoProvider.getOne(
      new ResourceFilter().equal(&#x27;id&#x27;, packageId),
      null,
      function(error, mediaPackage) {
        if (error) {
          self.emit(
            &#x27;error&#x27;,
            new PublishError(
              &#x27;Getting package &#x27; + packageId + &#x27; failed with message : &#x27; + error.message,
              ERRORS.UNKNOWN
            )
          );
        } else if (!mediaPackage) {

          // Package does not exist
          self.emit(
            &#x27;error&#x27;,
            new PublishError(&#x27;Cannot upload package &#x27; + packageId + &#x27; (not found)&#x27;, ERRORS.PACKAGE_NOT_FOUND)
          );

        } else if (mediaPackage.state === STATES.WAITING_FOR_UPLOAD) {

          // Package is indeed waiting for upload
          self.videoProvider.updateState(mediaPackage.id, STATES.PENDING, function() {

            // Upload officially started
            self.emit(&#x27;upload&#x27;, mediaPackage);
            self.emit(&#x27;stateChanged&#x27;, mediaPackage);

          });
          self.videoProvider.updateType(mediaPackage.id, platform);

          var mediaPackageManager = createMediaPackageManager.call(self, mediaPackage);
          process.logger.info(&#x27;Force upload package &#x27; + mediaPackage.id);
          mediaPackage.type = platform;
          mediaPackageManager.init(mediaPackage.lastState, mediaPackage.lastTransition);

          // Package can be added to pending packages
          if (addPackage.call(self, mediaPackage))
            mediaPackageManager.executeTransition(mediaPackage.lastTransition);

        }

      }
    );
  }
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
